\section{Chord Progression Comparisons}

\subsection{Considerations}

Computationally comparing chord progressions and approximating subjective human notions of similarity is a difficult task. Influential or unique chord progressions are frequently discussed in cultural contexts \cite{ogihara2008n}. Looking for local similarities between chord progressions has proved effective\cite{hanna2009alignment} and seems to match human intuition. When songs are said to be similar it does not mean that both songs' progressions are similar globally, or throughout the entire song, but rather that there are identical or near-identical local sections of similarity. For instance, The Beatles song \textit{Let It Be} has a progression of $I - V - vi - IV$ occurring at the beginning and frequently during the song. The chorus starts with a different progression but \textit{Let It Be} is still classed with songs of the progression $I - V - vi - IV$ and is included on Wikipedia's "List of songs containing the I–V–vi–IV progression," which at the time of writing includes 189 songs\cite{wikiprog1}. Another famous progression, $vi-IV-I-V$ (which is a cyclic shift of the previous progression), has even been dubbed the "Sensitive Female Chord Progression" for its use in countless pop songs\cite{hirsh2008}.

Chord progression identity is a salient factor in harmonically understanding a song, and preserving notions of local similarity is essential. The following sections detail algorithms that can be used to compare chord progressions, their advantages and disadvantages, and basic experimental results, if any.

\subsection{Simple Global Comparison}

This is perhaps the most basic implementation of chord progression comparison. For two songs with chord progressions ${c1}$ and ${c2}$ of an identical length $n$, the algorithm iterates through one chord from each song simultaneously and computes a chordal distance between the pair of chords using a distance function $C_d$ in which higher scores indicate stronger similarity. The resulting score is: \[ \sum_{i=0}^n C_d({c1}_i, c2_i) \]

Since the songs may be in different keys, the algorithm can iterate over all 12 transpositions of a song and pick out the maximal result. Given a chord transposition function $t_s$ that transposes a chord by $s$ semitones, the algorithm can be written: \[ \max_{s=0}^{12} \sum_{i=0}^n C_d({c1}_i, t_s({c2}_i)) \]

For songs of unequal length ${n1}$ and ${n2}$ with chord progressions ${c1}$ and ${c2}$, respectively, the algorithm can be revised by computing the maximum resulting score at each position of the shorter song shifted along the longer song. Assuming the second song is the shorter song $({n2} < {n1})$, the revised resulting score can be computed: \[ \max_{s=0}^{12} \max_{i=0}^{{n1} - {n2}} \sum_{j=0}^{n2} C_d({c1}_{i+j}, t_s({c2}_j)) \]

The advantages of the simple global comparison are that the algorithm is simple to implement and compute. Its computation costs are relatively low with a linear running time in the case of equal chord progression lengths. Unfortunately, in unequal song length comparisons the running time is quadratic in terms of the product of both songs' chordal lengths. These computation times are assuming a constant-time distance function.

The disadvantages of global comparison are that it neglects the power of local comparisons and does not correct well for errors in automated chord progression analysis. For instance, let ${c1}$ be the chord progression, $(Am, Dm, E7, Am, ... , Am, Dm, E7, Am)$ where the four chords $(Am, Dm, E7, Am)$ repeat 100 times. Let ${c2}$ be the same chord progression but there is an extra $E$ chord after the 50th iteration due to a flawed extraction. The global comparison score using ${c1}$ and ${c2}$ will be roughly cut in half due to that singular error and the issue with the ensuing alignment, with more errors resulting in worse scores.

\subsection{N-Gram Comparison}

To attempt to enhance the power of localized comparisons, \textit{n-grams} can be used to measure distances between chord subsequences. An n-gram is just a sequence of a fixed length $n$, where 2-gram would refer to a sequence of length 2, 3-gram would refer to a sequence of length 3, and so on. Using two sliding windows fixed at length $n_g$, both songs can be traversed to calculate chordal distances between every n-gram in both songs and sum the distances. The chordal distance between two n-grams can be calculated by summing the chordal distance of each vertical pair of chords within the n-gram (see figure~\ref{fig:ngram}), essentially the global comparison algorithm of equal length applied within a small window. This can be expressed: \[\sum_{i=0}^{n1 - n_g} \sum_{j=0}^{n2 - n_g} \left( \sum_{k=0}^{n_g} C_d({c1}_{i+k}, {c2}_{j+k}) \right) \]