\chapter{Code Implementation}

This chapter discusses in brief the manner in which I implemented my code. The full project is over 6,000 lines of C, Python, HTML, and Javascript code. This chapter will only overview notable features of the code.

\section{Using the chord alphabet}

\subsection{Integer representation of chords}

The Smith-Waterman algorithm is typically used in bioinformatic applications in which the alphabet is restricted to DNA or protein characters. To use an alphabet that contains all the chord symbols, a bijective function can be established between every type of chord and a unique 16 bit integer. Recall a chord can be described with the following grammar:
\begin{align*}
Chord &\to Root\ Harmony \ Bass \mid \textbf{NoChord} \\
Root &\to PitchClass \\
Bass &\to PitchClass \\
PitchClass &\to \textbf{A} \mid \textbf{A#/Bb} \mid \textbf{B} \mid \textbf{C} \mid \textbf{C#/Db} \mid \textbf{D} \mid \textbf{D#/Eb} \mid \textbf{E} \mid \textbf{F} \mid \textbf{F#/Gb} \mid \textbf{G} \mid \textbf{G#/Ab} \\
Harmony &\to \textbf{maj} \mid \textbf{6} \mid \textbf{maj7} \mid \textbf{m} \mid \textbf{m6} \mid \textbf{m7} \mid \textbf{7} \mid \textbf{aug} \mid \textbf{dim} \mid \textbf{dim7} \mid \textbf{m7b5} \mid \textbf{UnknownHarmony}
\end{align*}

Notice that $|Root| = |Bass| = |PitchClass| = 12$ and $|Harmony| = 12$. A bijective function $p$ between $PitchClass$ and an integer from 0 through 11 can be established, along with a bijective function $h$ between $Harmony$.

\begin{tabular}{llcll}
$PitchClass$ & $p(PitchClass)$ & \hspace*{2cm} & $Harmony$ & $h(Harmony)$ \\
\cmidrule(r){1-2} \cmidrule(r){4-5}
\textbf{A}     & 0  & & \textbf{maj} & 0 \\
\textbf{A#/Bb} & 1  & & \textbf{6} & 1 \\
\textbf{B}     & 2  & & \textbf{maj7} & 2 \\
\textbf{C}     & 3  & & \textbf{m} & 3 \\
\textbf{C#/Db} & 4  & & \textbf{m6} & 4 \\
\textbf{D}     & 5  & & \textbf{m7} & 5 \\
\textbf{D#/Eb} & 6  & & \textbf{7} & 6 \\
\textbf{E}     & 7  & & \textbf{aug} & 7 \\
\textbf{F}     & 8  & & \textbf{dim} & 8 \\
\textbf{F#/Gb} & 9  & & \textbf{dim7} & 9 \\
\textbf{G}     & 10 & & \textbf{m7b5} & 10 \\
\textbf{G#/Ab} & 11 & & \textbf{UnknownHarmony} & 11 \\ \\
\end{tabular}

In base 12, a chord that is not \textbf{NoChord} can be represented as an integer in which the digits are positioned as follows:

\begin{center}
\framebox[1.5\width]{$p(Bass)$ (0-11)}\framebox[1.5\width]{$p(Root)$ (0-11)}\framebox[1.5\width]{$h(Harmony)$ (0-11)}
\end{center}

This can be calculated as $(12 \cdot 12) \cdot p(Bass) + 12 \cdot p(Root) + h(Harmony)$. To include \textbf{NoChord}, the base 12 representation of a chord can be shifted by $1$ and $0$ can be reserved for \textbf{NoChord}, thus a bijective function $ChordToInt$ to map any chord $c$ to an integer can be calculated as follows:

\[
ChordToInt(c) = 
\begin{cases}
0 & \text{if }c = \textbf{NoChord} \\
144 \cdot p(Bass) + 12 \cdot p(Root) + h(Harmony) + 1 & \text{otherwise}
\end{cases}
\]


Extracting features from an integer $i$ representing a chord is then a simple task that can be represented in psuedocode as follows:

\begin{verbatim}
function ExtractFeatures(i)
  if (i = 0)
    return NoChord
  else
    Bass = (i - 1) / 144
    Root = ((i - 1) / 12) mod 12
    Harmony = (i - 1) mod 12
    return (Bass, Root, Harmony)
\end{verbatim}

\subsection{Bitwise representation of harmony}

Chord quality can be represented as a 12-bit integer in which each bit corresponds to whether a certain interval is included. This compact form provides a means for quick computation and allows chord set operations to be expressed with bitwise operators.

Let $i$ be a 12-bit integer representing chord quality in which each bit corresponds to whether a certain interval is included in the chord or not. Since leading 0's are excluded, the representation can start with 1 in the first binary position (right-to-left) to represent the root of the chord and each subsequent binary position $i, 1 \leq i \leq 12$ can represent whether the interval $i$ is included (where 0 is the root note) (see figure~\ref{fig:qualitytable}). All harmonies used in the program and associated intervals can be seen in figure~\ref{fig:qualitybitstable}. Let $h_b$ be the function that extracts the binary mask from a given harmony.

\begin{figure}[h!]
\centering
\begin{tabular}{llll}
\toprule
Chord Quality       & Shorthand & Binary Representation & Base 10 Representation \\
\midrule
Major               &           & 10010001     & 145  \\
Major 6th           & 6         & 10001001     & 137  \\
Major 7th           & maj7      & 1001001      & 73   \\
Minor               & m         & 100010001    & 273  \\
Minor 6th           & m6        & 100010010001 & 2193 \\
Minor 7th           & m7        & 10010001001  & 1161 \\
Dominant 7th        & 7         & 10010010001  & 1169 \\
Augmented           & aug       & 1001001001   & 585  \\
Diminished          & dim       & 10001001001  & 1097 \\
Diminished 7th      & dim7      & 1010010001   & 657  \\
Half-diminished 7th & m7b5      & 1010001001   & 649  \\
\bottomrule
\end{tabular}
\caption{Binary Representation of Chords}
\label{fig:qualitybitstable}
\end{figure}

\subsection{Bitwise chord operations}

Basic chord operations can then be constructed. For instance, to get $P_c(c)$ as a 12-bit integer in which each bit $i$ from right-to-left corresponds to whether $p(i) \in P_c(c)$ one need only construct a bit cycling algorithm
\begin{verbatim}
function CycleBits(value, shift)
  return ((value << shift) | (value >> (12 - shift))) & b111111111111
\end{verbatim}
where \texttt{b111111111111} refers to the binary bitmask of all 1's for 12 places, \texttt{<<} and \text{>>} are the bit shift left and right operators, and \texttt{|} and \texttt{&} are the bit operators $and$ and $or$, respectively. $P_c(c)$ can then be calculated: \[ P_c(c) = CycleBits(h_b(quality(c)), p(root(c))) | p(bass(c)) \]

Cleverness with representing chords and harmonies as integers allows effective methods to be constructed with simple bitwise operations and bitmasks.

\section{Smith-Waterman MIPS Implementation}

\item Used BU implementation, extreme speed results, but only for DNA and Protein sequences, the usual use case of Smith-Waterman

\item Optimized implementation for use with chord alphabet

\item Initialize distance matrix, extremely fast

\subsection{Speed considerations}

\item Initially implemented in Python, experience 100,000x speed-up

\subsection{Future considerations}

\item Fast SW extremely useful but also highly restrictive in its compactness and efficiency -- hard to modify

\item Adapt using local transpositions