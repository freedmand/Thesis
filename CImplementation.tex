\chapter{Code Implementation}

\section{Smith-Waterman}

\subsection{Using the chord alphabet}

The Smith-Waterman algorithm is typically used in bioinformatic applications in which the alphabet is restricted to DNA or protein characters. To use an alphabet that contains all the chord symbols, a bijective function can be established between every type of chord and a unique 16 bit integer. Recall a chord can be described with the following grammar:

\begin{align*}
Chord &\to Root\ Harmony \ Bass \mid \textbf{NoChord} \\
Root &\to PitchClass \\
Bass &\to PitchClass \\
PitchClass &\to \textbf{A} \mid \textbf{A#/Bb} \mid \textbf{B} \mid \textbf{C} \mid \textbf{C#/Db} \mid \textbf{D} \mid \textbf{D#/Eb} \mid \textbf{E} \mid \textbf{F} \mid \textbf{F#/Gb} \mid \textbf{G} \mid \textbf{G#/Ab} \\
Harmony &\to \textbf{maj} \mid \textbf{6} \mid \textbf{maj7} \mid \textbf{m} \mid \textbf{m6} \mid \textbf{m7} \mid \textbf{7} \mid \textbf{aug} \mid \textbf{dim} \mid \textbf{dim7} \mid \textbf{m7b5} \mid \textbf{UnknownHarmony}
\end{align*}

Notice that $|Root| = |Bass| = |PitchClass| = 12$ and $|Harmony| = 12$. A bijective function $p$ between $PitchClass$ and an integer from 0 through 11 can be established, along with a bijective function $h$ between $Harmony$.

\begin{tabular}{llcll}
\toprule
$PitchClass$ & $p(PitchClass)$ & \hspace*{2cm} & $Harmony$ & $h(Harmony)$ \\
\cmidrule(r){1-2} \cmidrule(r){4-5}
\textbf{A}     & 0  & & \textbf{maj} & 0 \\
\textbf{A#/Bb} & 1  & & \textbf{6} & 1 \\
\textbf{B}     & 2  & & \textbf{maj7} & 2 \\
\textbf{C}     & 3  & & \textbf{m} & 3 \\
\textbf{C#/Db} & 4  & & \textbf{m6} & 4 \\
\textbf{D}     & 5  & & \textbf{m7} & 5 \\
\textbf{D#/Eb} & 6  & & \textbf{7} & 6 \\
\textbf{E}     & 7  & & \textbf{aug} & 7 \\
\textbf{F}     & 8  & & \textbf{dim} & 8 \\
\textbf{F#/Gb} & 9  & & \textbf{dim7} & 9 \\
\textbf{G}     & 10 & & \textbf{m7b5} & 10 \\
\textbf{G#/Ab} & 11 & & \textbf{UnknownHarmony} & 11 \\ \\
\end{tabular}

In base 12, a chord that is not \textbf{NoChord} can be represented as an integer in which the digits are positioned as follows:

\framebox[1.1\width]{\textbf{Bass} (0-11)}\framebox[1.1\width]{\textbf{Root} (0-11)}\framebox[1.1\width]{\textbf{Harmony} (0-11)}

This can be calculated as $(12 \cdot 12) \textbf{Bass} + 12 \textbf{Root} + \textbf{Harmony}$. To include \textbf{NoChord}, the base 12 representation of a chord can be shifted by $1$ and $0$ can be reserved for \textbf{NoChord}, thus a bijective function $ChordToInt$ to map any chord $c$ to an integer can be calculated as follows:

\[
ChordToInt(c) = 
\begin{cases}
0 & \text{if }c = \textbf{NoChord} \\
144 \textbf{Bass} + 12 \textbf{Root} + \textbf{Harmony} + 1 & \text{otherwise}
\end{cases}
\]

\item Chord data structures (alphabet), base 12 representation

\item Ignoring duration (future work)

\subsection{Bitwise representation of harmonies}

\item Cleverness with representing chords and harmonies as integers and allowing simple bitwise operations and bitmasks

\subsection{MIPS Implementation}

\item Used BU implementation, extreme speed results, but only for DNA and Protein sequences, the usual use case of Smith-Waterman

\item Optimized implementation for use with chord alphabet

\item Initialize distance matrix, extremely fast

\subsection{Speed considerations}

\item Initially implemented in Python, experience 100,000x speed-up

\subsection{Future considerations}

\item Fast SW extremely useful but also highly restrictive in its compactness and efficiency -- hard to modify

\item Adapt using local transpositions