\chapter{Code Implementation}

This chapter discusses in brief the manner in which I implemented my code. The full project is over 6,000 lines of C, Python, HTML, and Javascript code. This chapter will only overview notable features of the code.

\section{Using the chord alphabet}

\subsection{Integer representation of chords} \label{intrep}

The Smith-Waterman algorithm is typically used in bioinformatic applications in which the alphabet is restricted to DNA or protein characters. To use an alphabet that contains all the chord symbols, a bijective function can be established between every type of chord and a unique 16 bit integer. Recall a chord can be described with the following grammar:
\begin{align*}
Chord &\to Root\ Harmony \ Bass \mid \textbf{NoChord} \\
Root &\to PitchClass \\
Bass &\to PitchClass \\
PitchClass &\to \textbf{A} \mid \textbf{A#/Bb} \mid \textbf{B} \mid \textbf{C} \mid \textbf{C#/Db} \mid \textbf{D} \mid \textbf{D#/Eb} \mid \textbf{E} \mid \textbf{F} \mid \textbf{F#/Gb} \mid \textbf{G} \mid \textbf{G#/Ab} \\
Harmony &\to \textbf{maj} \mid \textbf{6} \mid \textbf{maj7} \mid \textbf{m} \mid \textbf{m6} \mid \textbf{m7} \mid \textbf{7} \mid \textbf{aug} \mid \textbf{dim} \mid \textbf{dim7} \mid \textbf{m7b5} \mid \textbf{UnknownHarmony}
\end{align*}

Notice that $|Root| = |Bass| = |PitchClass| = 12$ and $|Harmony| = 12$. A bijective function $p$ between $PitchClass$ and an integer from 0 through 11 can be established, along with a bijective function $h$ between $Harmony$.

\begin{tabular}{llcll}
$PitchClass$ & $p(PitchClass)$ & \hspace*{2cm} & $Harmony$ & $h(Harmony)$ \\
\cmidrule(r){1-2} \cmidrule(r){4-5}
\textbf{A}     & 0  & & \textbf{maj} & 0 \\
\textbf{A#/Bb} & 1  & & \textbf{6} & 1 \\
\textbf{B}     & 2  & & \textbf{maj7} & 2 \\
\textbf{C}     & 3  & & \textbf{m} & 3 \\
\textbf{C#/Db} & 4  & & \textbf{m6} & 4 \\
\textbf{D}     & 5  & & \textbf{m7} & 5 \\
\textbf{D#/Eb} & 6  & & \textbf{7} & 6 \\
\textbf{E}     & 7  & & \textbf{aug} & 7 \\
\textbf{F}     & 8  & & \textbf{dim} & 8 \\
\textbf{F#/Gb} & 9  & & \textbf{dim7} & 9 \\
\textbf{G}     & 10 & & \textbf{m7b5} & 10 \\
\textbf{G#/Ab} & 11 & & \textbf{UnknownHarmony} & 11 \\ \\
\end{tabular}

In base 12, a chord that is not \textbf{NoChord} can be represented as an integer in which the digits are positioned as follows:

\begin{center}
\framebox[1.5\width]{$p(Bass)$ (0-11)}\framebox[1.5\width]{$p(Root)$ (0-11)}\framebox[1.5\width]{$h(Harmony)$ (0-11)}
\end{center}

This can be calculated as $(12 \cdot 12) \cdot p(Bass) + 12 \cdot p(Root) + h(Harmony)$. To include \textbf{NoChord}, the base 12 representation of a chord can be shifted by $1$ and $0$ can be reserved for \textbf{NoChord}, thus a bijective function $ChordToInt$ to map any chord $c$ to an integer can be calculated as follows:

\[
ChordToInt(c) = 
\begin{cases}
0 & \text{if }c = \textbf{NoChord} \\
144 \cdot p(Bass) + 12 \cdot p(Root) + h(Harmony) + 1 & \text{otherwise}
\end{cases}
\]


Extracting features from an integer $i$ representing a chord is then a simple task that can be represented in psuedocode as follows:

\begin{verbatim}
function ExtractFeatures(i)
  if (i = 0)
    return NoChord
  else
    Bass = (i - 1) / 144
    Root = ((i - 1) / 12) mod 12
    Harmony = (i - 1) mod 12
    return (Bass, Root, Harmony)
\end{verbatim}

\subsection{Bitwise representation of harmony}

Chord quality can be represented as a 12-bit integer in which each bit corresponds to whether a certain interval is included. This compact form provides a means for quick computation and allows chord set operations to be expressed with bitwise operators.

Let $i$ be a 12-bit integer representing chord quality in which each bit corresponds to whether a certain interval is included in the chord or not. Since leading 0's are excluded, the representation can start with 1 in the first binary position (right-to-left) to represent the root of the chord and each subsequent binary position $i, 1 \leq i \leq 12$ can represent whether the interval $i$ is included (where 0 is the root note) (see figure~\ref{fig:qualitytable}). All harmonies used in the program and associated intervals can be seen in figure~\ref{fig:qualitybitstable}. Let $h_b$ be the function that extracts the binary mask from a given harmony.

\begin{figure}[h!]
\centering
\begin{tabular}{llll}
\toprule
Chord Quality       & Shorthand & Binary Representation & Base 10 Representation \\
\midrule
Major               &           & 10010001     & 145  \\
Major 6th           & 6         & 10001001     & 137  \\
Major 7th           & maj7      & 1001001      & 73   \\
Minor               & m         & 100010001    & 273  \\
Minor 6th           & m6        & 100010010001 & 2193 \\
Minor 7th           & m7        & 10010001001  & 1161 \\
Dominant 7th        & 7         & 10010010001  & 1169 \\
Augmented           & aug       & 1001001001   & 585  \\
Diminished          & dim       & 10001001001  & 1097 \\
Diminished 7th      & dim7      & 1010010001   & 657  \\
Half-diminished 7th & m7b5      & 1010001001   & 649  \\
\bottomrule
\end{tabular}
\caption{Binary Representation of Chords}
\label{fig:qualitybitstable}
\end{figure}

\subsection{Bitwise chord operations}

Basic chord operations can then be constructed. For instance, to get $P_c(c)$ as a 12-bit integer in which each bit $i$ from right-to-left corresponds to whether $p(i) \in P_c(c)$ one need only construct a bit cycling algorithm
\begin{verbatim}
function CycleBits(value, shift)
  return ((value << shift) | (value >> (12 - shift))) & b111111111111
\end{verbatim}
where \texttt{b111111111111} refers to the binary bitmask of all 1's for 12 places, \texttt{<<} and \text{>>} are the bit shift left and right operators, and \texttt{|} and \texttt{&} are the bit operators $and$ and $or$, respectively. $P_c(c)$ can then be calculated: \[ P_c(c) = CycleBits(h_b(quality(c)), p(root(c))) | p(bass(c)) \]

Cleverness with representing chords and harmonies as integers allows effective methods to be constructed with simple bitwise operations and bitmasks.

\section{Smith-Waterman SIMD Implementation}

\subsection{Initial implementations}

To get my ideas off the ground, I initially implemented the Smith-Waterman algorithm for use with chords in Python, using high-level data types rather than integers to represent chords and calculating chord distances on the fly rather than pre-populating a distance matrix.

This implementation was effective for rapid prototyping, developing a deeper understanding of the algorithm, and being able to quickly add features like matrix output harnessing the power of Python's external libraries. Unfortunately, the code was extremely slow, taking in the ballpark of 4 seconds to compare two songs with around 150 chords each using adaptations of the simple equality chord distance metric. This speed compares with another paper that details implementation of a chord progression distance comparison based off of Smith-Waterman that had a runtime of 2-9 days to compare 5000 songs\cite{de2010comparing}. A limitation in the current research of chord sequence alignment systems (CSAS) is the slow runtime.

I attempted to improve the runtime by reimplementing the algorithm in its entirety in C, using bit representations of chords and precomputing distance matrices, achieving a speed increase of about 130x from the Python implementation.

\subsection{Adapting an external C implementation}

To attempt to increase the speed of the Smith-Waterman algorithm even more, such that it would not be an issue, I adapted a Smith-Waterman C implementation that uses Single-Instruction, Multiple-Data (SIMD) parallel computing instructions for use with the chord alphabet\cite{Zhao_2013}\footnote{https://github.com/mengyao/Complete-Striped-Smith-Waterman-Library}. SIMD instructions, which almost all modern computer architectures have, operate on vectors of small data in parallel by representing the vectors as single integers. For instance, two 128-bit integers containing 16 8-bit integers can be operated on simultaneously to achieve tasks like adding all 16 of the 8-bit integers within each 128-bit integer in a single computer instruction.

The SIMD Smith-Waterman algorithm uses advances in Smith-Waterman calculations\cite{chao1992aligning} in combination with SIMD instructions that can massively parallelize the algorithm at no additional computational cost. A problem I encountered was that this particularly SIMD implementation was only attuned for 8-bit integers that could represent the alphabets of DNA sequences and protein sequences. I modified the source code to support the 16-bit representation I constructed of chords detailed in section~\ref{intrep} while preserving the runtime of the algorithm, facilitating the use of the SIMD Smith-Waterman algorithm to my chord progressions. To my knowledge, this is the fastest implementation of chord sequence alignment that currently exists. The runtime of this adapted algorithm compared with the initial Python implementation has a speed-up of over 113,000x.

\subsection{Rounding Chord Distance Metrics} \label{roundchord}

Chord distance values, in the SIMD implementation of Smith-Waterman, are represented as 8-bit integers; this does not blend out of the box with the floating point data the chord distance metrics proposed in section~\ref{chordmet}. A workable solution is to take the chord distance score $C_d$ and round it to the nearest integer after multiplying it \[ C_{rd} = round(C_d \cdot m_x) \] for some multiplication factor $m_x$. To produce chord distance scores with an expected value below $0$, a subtraction factor $m_s$ can also be introduced: \[ C_{rd} = (round(C_d) \cdot m_x) - m_s \]

\section{Dataset Collection}

\textit{Scraping} refers to the task of writing scripts to automatically extract files and download them. What follows is a brief overview of how I collected, or scraped, the datasets I am using in my evaluations.

\subsection{File conversion}

To convert collected files---which come in a variety of audio formats such as \textit{mp3}, \textit{aac}, and \textit{ogg}, and video formats such as \textit{mp4}---to \textit{wav} files necessitated using the external library \textit{ffmpeg}. ffmpeg contains code to convert a wide range of audiovisual file types to other file types. To feed chord data into Chordino via a command line script requires the use of \textit{wav} files, so all input audio files were converted to \textit{wav} for the purpose of chord extraction. I wrote a wrapper to convert files and analyze their chordal content with Chordino in Python.

\subsection{YouTube Extraction}

This method of data collection concerns downloading from YouTube\footnote{https://www.youtube.com/} videos and playlists. Using the Python extension \textit{youtube\_dl}\footnote{https://pypi.python.org/pypi/youtube\_dl}, I bulk downloaded videos from external user-created playlists corresponding to the data I wanted to extract. I only used this technique to collect the Billboard 2014 Dataset, which consists of over 200 top contemporary billboard charts in the United States. After downloading these files in \textit{mp4} format, I converted them to \textit{wav} files and extracted their chord progressions using Chordino.

\subsection{Rhapsody}

\textit{Rhapsody}\footnote{https://www.rhapsody.com/} is a popular music streaming service that allows users to listen to a huge database of music for a low monthly fee. Already being a Rhapsody, I used a Python script called \texttt{rapi.py}\footnote{https://github.com/davekilian/rapi/blob/master/rapi.py}, an unofficial Rhapsody API that can be used to download streams given valid login credentials.

The McGill Billboard Project Dataset\cite{BurgoyneEtAl_2011_AnExpeGrouSet}, which consists of a large collection of ground-truth annotations for Billboard charts from 1950 through 1990, does not contain the corresponding audio files that could be used to create extracted annotations for comparison. I wrote a Python program that looks up the title, artist, and duration of the included metadata in the dataset using the Python extension \textit{pyechonest}\footnote{https://github.com/echonest/pyechonest} which queries the Echonest\footnote{http://the.echonest.com/} API, a musical intelligence project that stores a massive amount of musical metadata. Some Echonest results include Rhapsody track ids that can be used to find the corresponding stream on Rhapsody. The Python program, for every successful match to Rhapsody, downloads the corresponding audio file, converts to \textit{wav}, and extracts chord progressions, leading to the creation of the McGill Extracted Dataset.

\subsection{National Anthems}

The National Anthems Dataset was collected from the Wikipedia page ``List of national anthems''\footnote{http://en.wikipedia.org/wiki/List\_of\_national\_anthems} which collects open source recordings of national anthems for every country recognized by the United Nations and a few other states and territories not officially recognized. Using Python to parse this web page, I downloaded all the audio files, which were in the \textit{ogg} format, an open-source alternative to mp3, converted the files to the \textit{wav} filetype, and ran chord extraction.