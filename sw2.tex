Another measure to normalize the Smith-Waterman score is
\[ SW_{norm}(c1,c2)=\frac{SW(c1,c2)}{\max [SW(c1,c1), SW(c2,c2)]} \]
which involves running the Smith-Waterman algorithm over chord progressions against themselves. This returns the score of identity in the distance metric multiplied by the length of the sequence being tested, which has a direct linear correlation with sequence length. Essentially, this is linearly equivalent to a normalization by dividing by the maximal length of the sequences being tested and returns values from 0.0 to 1.0.

The only normalization measures considered in this paper are \textit{raw score} and this measure I call $SW_{norm}$.

% % C, F, C, *,  G, F, C, G,  Dm, C
% %   |  |  ins |  |  |  del |   |
% %   F, C, Dm, G, F, C, *,  Dm, C, F


% \item Localized comparison, dynamic programming, find minimum number of required "transformations" and optimal localized slice. Dynamic programming

% \item Works well with inexact data, can deal with common pitfalls of chord extraction.

% \item Isolates similar substructures.

% \item Does not penalize closely related chords, i.e. Em7 and Gmaj

% \item Difficulty in extracting multiple "best" options but good at finding one top contender

% \item Difficulty in comparing scores

% \subsection{Example Smith-Waterman Algorithm}

% The following example shows how the Smith-Waterman algorithm could be applied to the alphabet of musical chord symbols:

% This example assumes the following costs:

% If the chord begins on the same root, then add 3 \\
% Otherwise, subtract 4 \\